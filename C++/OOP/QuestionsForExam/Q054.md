# Вопрос 54

Обращение к члену родительского класса извне возможно только если он не является абстрактным. Обращение извне происходит также как к любому классу: через операторы `.*` и `->*`.
Операторы `.*` указателя на члены и `->*` возвращают значение определенного члена класса для объекта, указанного слева от выражения. Правая часть должна определять член класса. В следующем примере показано использование этих операторов.
```cpp
#include <iostream>

using namespace std;

class Testpm
{
public:
   void m_func1() { cout << "m_func1\n"; }
   int m_num;
};

void (Testpm::*pmfn)() = &Testpm::m_func1;
int Testpm::*pmd = &Testpm::m_num;

int main()
{
   Testpm ATestpm;
   Testpm *pTestpm = new Testpm;

   (ATestpm.*pmfn)();
   (pTestpm->*pmfn)();

   ATestpm.*pmd = 1;
   pTestpm->*pmd = 2;

   cout  << ATestpm.*pmd << endl
         << pTestpm->*pmd << endl;
   delete pTestpm;
}
```
Выходные данные
```
m_func1
m_func1
1
2
```
В приведенном выше примере указатель на член, `pmfn`, используется для вызова функции-члена `m_func1`. Другой указатель на член, `pmd`, используется для обращения к члену `m_num`.

Бинарный оператор `.*` объединяет свой первый операнд, который должен быть объектом типа класса, со вторым операндом, который должен быть типом указателя на член.

Бинарный оператор `->*` объединяет свой первый операнд, который должен быть указателем на объект типа класса, со вторым операндом, который должен быть типом указателя на член.

В выражении, содержающем `.*` оператор, первый операнд должен иметь тип класса и быть доступным для элемента, указанного во втором операнде или доступном для этого класса.

В выражении, содержающем `->*` оператор, первый операнд должен иметь тип "указатель на тип класса" типа, указанного во втором операнде, или он должен быть однозначно производным от этого класса.

Обращение из производных классов происходит через оператор `::`, т.е. используя пространство имен родительского класса.

```cpp
class A
{
public:
   int a;
   void foo(){}
};

class B : public A
{
public:
   int b;
   void foo()
   {
      A::foo();
   }
};
```