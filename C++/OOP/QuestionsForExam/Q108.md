# Задача 1

## Перегрузка функций 
Что же такое перегрузка? В Си может быть только одна функция с одним именем. Например, представим себе семейство функций, которые выводят на экран некоторое значение (число или строку). В Си мы могли бы описать их так:
``` c
void print_int (int v);
void print_float (float v);
void print_zts (const char *v);
… … …
int main () {
  print_int (10);
  print_float (5.5);
  print_zts ("Hello, world!\n");
}
```
Однако на самом деле, когда мы вызываем `print_нечто (10)`, компилятор уже знает, что 10 — это целое число. Но он никак не даёт нам воспользоваться этим знанием, и нам приходится вручную говорить, что печатаем мы именно int: `print_int (10)`.

Си++ как раз позволяет предоставить компилятору задачу по выбору нужного варианта функции. Для этого мы можем определить набор функций, каждая из которых имеет имя `print`, но которые принимают разные аргументы. Предыдущий пример тогда будет выглядеть следующим образом:
``` cpp
void print (int v);
void print (float v);
void print (const char *v);
… … …
int main () {
  print (10);
  print (5.5);
  print ("Hello, world!\n");
}
```
## Пробразование типов

Cи-стиль приведения типов данных доступен и языке C++, но считается не самодостаточным по сравнению с приведением типов в C++. Так как Си-стиль приведения типов не так точен, как C++-стиль приведения и не так заметен. Cи-стиль приведения типов данных может быть использован для преобразования любого типа в любой другой тип, при этом неважно насколько это небезопасное преобразование, например, преобразование целого числа в указатель типа `int`). Казалось бы, такое преобразование невозможно, однако компилятор с нами не согласен, но выполнит это приведение. И каков получится результат. ему совершенно не важно. Смотрим синтаксис приведения типов данных согласно Си-стилю:

``` c
(type) value
```
* где `type` — тип данных к которому преобразуется значение `val`

### static_cast — унарная операция приведения типов данных в С++
Операция `static_cast` доступна только в языке C++. `static_cast` может быть использована для преобразования одного типа в другой, но она не должна быть использована для выполнения недопустимого преобразования, например, преобразование значения в указатель или наоборот. Рекомендуется пользоваться операцией `static_cast`, нежели Cи-стилем приведения, потому что `static_cast` ограничивает недопустимое приведение типов и, следовательно — безопаснее.

Операция `static_cast`, грубо говоря, — это шаблон функции, в которой необходимо явно указать  тип данных для преобразования, то есть задать параметр шаблона.

``` cpp
static_cast<dataType>(value);
```

### dynamic_cast — унарная операция приведения типов данных в С++
Операция `dynamic_cast` доступна только в C++ и имеет смысл только, применительно к членам класса иерархии «полиморфных типов». Динамическое приведение типов данных может быть использовано для безопасного приведения указателя (или ссылки) на суперкласс, в указатель (или ссылку) на подкласс в иерархии классов. Если динамическое приведение типов — недопустимо, так как реальный тип объекта, указывает не на тот тип подкласса, приведение типов не выполнится.

Динамическое приведение указателя
При приведении указателя, в случае неудачи, `dynamic_cast` возвращает нулевой указатель NULL. Такое поведение обеспечивает быстрый способ определения, является ли данный объект частностью динамического типа.

``` cpp
type *subСlass = dynamic_cast<type *>(objPtr);
```

### const_cast — константное приведение типов данных
Операция `const_cast` доступна только в C++. Константное приведение используются, чтобы  константную переменную преобразовать в неконстантную. При этом, константным становится возвращаемое значение операции `const_cast`, а не сама переменная.

``` cpp
const_cast<dataType>(val);
```

### reinterpret_cast — операция приведения типов данных
Операция `reinterpret_cast` доступна только в C++ и является наименее безопасной формой приведения типов данных в С++, она позволяет интерпретировать значение в другой тип данных. `reinterpret_cast` не должна быть использована для приведения иерархии классов или преобразования константных переменных.

``` cpp
reinterpret_cast<dataType>(value);
```

## Доступ к полям
В C++ появились классы и объекты. Технически класс C++ - это тип структуры в C, а объект - переменная такого типа. Разница только в том, что в C++ есть еще модификаторы доступа и полями могут быть не только данные, но и функции (функции-методы).

Функция-метод - это обычная функция C, у которой первый параметр - это указатель на структуру, данные которой она обрабатывает: `this`. Если сравнить, как выглядят функции-методы в C++ и функции с параметром-указателем на структуру в C, то мы обнаружим, что всего лишь изменилась форма записи. В C++ получается короче, так как `this` и имя типа во многих случаях писать не обязательно (подразумевается по умолчанию).

Модификаторы доступа - это слова `public`, `private` и `protected`. В C вместо них была внимательность программиста: `public` - значит с этими полями делаю, что хочу; `private` - значит к этим полям обращаюсь только с помощью методов этой структуры; `protected` - то же, что `private`, но еще можно обращаться из методов унаследованных структур 